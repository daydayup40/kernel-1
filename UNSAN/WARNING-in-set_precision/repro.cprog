// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE 
#include <endian.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <linux/futex.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

struct thread_t {
	int created, running, call;
	pthread_t th;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;
static int collide;

static void* thr(void* arg)
{
	struct thread_t* th = (struct thread_t*)arg;
	for (;;) {
		while (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE))
			syscall(SYS_futex, &th->running, FUTEX_WAIT, 0, 0);
		execute_call(th->call);
		__atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
		__atomic_store_n(&th->running, 0, __ATOMIC_RELEASE);
		syscall(SYS_futex, &th->running, FUTEX_WAKE);
	}
	return 0;
}

static void execute(int num_calls)
{
	int call, thread;
	running = 0;
	for (call = 0; call < num_calls; call++) {
		for (thread = 0; thread < sizeof(threads) / sizeof(threads[0]); thread++) {
			struct thread_t* th = &threads[thread];
			if (!th->created) {
				th->created = 1;
				pthread_attr_t attr;
				pthread_attr_init(&attr);
				pthread_attr_setstacksize(&attr, 128 << 10);
				pthread_create(&th->th, &attr, thr, th);
			}
			if (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE)) {
				th->call = call;
				__atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
				__atomic_store_n(&th->running, 1, __ATOMIC_RELEASE);
				syscall(SYS_futex, &th->running, FUTEX_WAKE);
				if (collide && call % 2)
					break;
				struct timespec ts;
				ts.tv_sec = 0;
				ts.tv_nsec = 20 * 1000 * 1000;
				syscall(SYS_futex, &th->running, FUTEX_WAIT, 1, &ts);
				if (running)
					usleep((call == num_calls - 1) ? 10000 : 1000);
				break;
			}
		}
	}
}

void execute_call(int call)
{
	switch (call) {
	case 0:
memcpy((void*)0x20000140, "dns_resolver", 13);
*(uint8_t*)0x20000080 = 0x73;
*(uint8_t*)0x20000081 = 0x79;
*(uint8_t*)0x20000082 = 0x7a;
*(uint8_t*)0x20000083 = 0;
*(uint8_t*)0x20000084 = 0;
		syscall(__NR_add_key, 0x20000140, 0x20000080, 0x20000240, 0xfda3, -1);
		break;
	case 1:
*(uint32_t*)0x20000400 = -1;
memcpy((void*)0x20000404, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x24\xe3\xcd\x6e\x99\x79\x9c\xc2\x9e\x2e\x80\x27\xc5\xad\xf7\xff\x01\xcc\xef\x47\x8e\xc2\x60\x69\x75\x8e\x23\x9a\x55\xcd\xdf\xcb\xf1\x57\x00\x54\x31\xba\x11\x05\x87\x05\x91\x32\x71\x1f\xd1\x4b\xec\x4b\x63\x28\x3a\xfd\x4f\xf2\x31\xe0\x37\x5d\x7b\x7d\x95\x7b\xe7\x85\x27\x1b\x82\xec\x0a\x35\x23\x56\xc0\x23\x45\x92\xee\x8e\x44\x76\x0d\x15\xa0\x41\x2a\x53\xe3\x94\xf1\x73\x6c\x7d\x8c\x56\xcc\x02\x70\xb4\x53\x05\xb9\xb6\x47\x37\x38\xbd\x37\xcf\x2a\x44\xd2\x17\xcc\xa0\xf9\x29\x57\xba\x69\xf6\x1d\xc3\x50\x87\x58\xec\x2e\x08\x5f\x9d\xe8\xe7\x0d\xc8\xca\x53\xeb\xd6\x82\x62\xda\x49\xf6\xf9\x06\x42\x17\xb8\x9d\xe9\xac\x91\x58\xef\x6a\x7b\x83\x6e\x19\xa2\x52\xfc\x4e\x31\x13\x24\x04\x59\xad\xbd\xfc\xf5\xfb\xa8\x35\x44\x3c\x6e\xfb\x5e\x05\x63\x86\x2f\xc1\x10\xa2\x08\x80\x15\x98\x27\xf8\xf2\x77\x78\x8b\x56\x8a\x94\x10\x81\xdf\x5c\xc9\xd8\x16\xcd\xb2\x73\xab\x1e\x1d\xfa\x21\x40\xb7\x83\x8f\xc2\x1d\x0d\x87\x2c\xb8\xa3\x7c\x02\xfe\x0b\x7f\xb6\x72\xc3\xc0\xe9\x06\xde\x3d\xfe\xbd\x6e\x45\x2f\xb6", 259);
		syscall(__NR_setsockopt, -1, 0x84, 0x77, 0x20000400, 2);
		break;
	}
}

void loop()
{
	execute(2);
	collide = 1;
	execute(2);
}

int main()
{
	syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
	loop();
	return 0;
}
