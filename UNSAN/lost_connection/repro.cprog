// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE 
#include <endian.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/prctl.h>
#include <dirent.h>
#include <sys/mount.h>

__attribute__((noreturn)) static void doexit(int status)
{
	volatile unsigned i;
	syscall(__NR_exit_group, status);
	for (i = 0;; i++) {
	}
}
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

const int kFailStatus = 67;
const int kRetryStatus = 69;

  static void fail(const char* msg, ...)
{
	int e = errno;
	va_list args;
	va_start(args, msg);
	vfprintf(stderr, msg, args);
	va_end(args);
	fprintf(stderr, " (errno %d)\n", e);
	doexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);
}

  static void exitf(const char* msg, ...)
{
	int e = errno;
	va_list args;
	va_start(args, msg);
	vfprintf(stderr, msg, args);
	va_end(args);
	fprintf(stderr, " (errno %d)\n", e);
	doexit(kRetryStatus);
}

static uint64_t current_time_ms()
{
	struct timespec ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts))
		fail("clock_gettime failed");
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir()
{
	char tmpdir_template[] = "./syzkaller.XXXXXX";
	char* tmpdir = mkdtemp(tmpdir_template);
	if (!tmpdir)
		fail("failed to mkdtemp");
	if (chmod(tmpdir, 0777))
		fail("failed to chmod");
	if (chdir(tmpdir))
		fail("failed to chdir");
}

static void remove_dir(const char* dir)
{
	DIR* dp;
	struct dirent* ep;
	int iter = 0;
retry:
	while (umount2(dir, MNT_DETACH) == 0) {
	}
	dp = opendir(dir);
	if (dp == NULL) {
		if (errno == EMFILE) {
			exitf("opendir(%s) failed due to NOFILE, exiting", dir);
		}
		exitf("opendir(%s) failed", dir);
	}
	while ((ep = readdir(dp))) {
		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
			continue;
		char filename[FILENAME_MAX];
		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
		struct stat st;
		if (lstat(filename, &st))
			exitf("lstat(%s) failed", filename);
		if (S_ISDIR(st.st_mode)) {
			remove_dir(filename);
			continue;
		}
		int i;
		for (i = 0;; i++) {
			if (unlink(filename) == 0)
				break;
			if (errno == EROFS) {
				break;
			}
			if (errno != EBUSY || i > 100)
				exitf("unlink(%s) failed", filename);
			if (umount2(filename, MNT_DETACH))
				exitf("umount(%s) failed", filename);
		}
	}
	closedir(dp);
	int i;
	for (i = 0;; i++) {
		if (rmdir(dir) == 0)
			break;
		if (i < 100) {
			if (errno == EROFS) {
				break;
			}
			if (errno == EBUSY) {
				if (umount2(dir, MNT_DETACH))
					exitf("umount(%s) failed", dir);
				continue;
			}
			if (errno == ENOTEMPTY) {
				if (iter < 100) {
					iter++;
					goto retry;
				}
			}
		}
		exitf("rmdir(%s) failed", dir);
	}
}

static void execute_one();
extern unsigned long long procid;

static void loop()
{
	int iter;
	for (iter = 0;; iter++) {
		char cwdbuf[32];
		sprintf(cwdbuf, "./%d", iter);
		if (mkdir(cwdbuf, 0777))
			fail("failed to mkdir");
		int pid = fork();
		if (pid < 0)
			fail("clone failed");
		if (pid == 0) {
			prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
			setpgrp();
			if (chdir(cwdbuf))
				fail("failed to chdir");
			execute_one();
			doexit(0);
		}

		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			int res = waitpid(-1, &status, __WALL | WNOHANG);
			if (res == pid) {
				break;
			}
			usleep(1000);
			if (current_time_ms() - start < 3 * 1000)
				continue;
			kill(-pid, SIGKILL);
			kill(pid, SIGKILL);
			while (waitpid(-1, &status, __WALL) != pid) {
			}
			break;
		}
		remove_dir(cwdbuf);
	}
}

uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};
void execute_one()
{
	long res = 0;
memcpy((void*)0x20000000, "./file1", 8);
	syscall(__NR_mkdir, 0x20000000, 1);
memcpy((void*)0x20000040, "./file1", 8);
memcpy((void*)0x20000740, "./file1", 8);
memcpy((void*)0x20000780, "sockfs", 7);
	syscall(__NR_mount, 0x20000040, 0x20000740, 0x20000780, 0x1000, 0x20000100);
memcpy((void*)0x20000140, "./file1", 8);
memcpy((void*)0x200001c0, "./file1", 8);
	syscall(__NR_pivot_root, 0x20000140, 0x200001c0);
	res = syscall(__NR_socket, 0xa, 2, 0);
	if (res != -1)
		r[0] = res;
	res = syscall(__NR_dup, r[0]);
	if (res != -1)
		r[1] = res;
*(uint32_t*)0x20000380 = htobe32(0);
*(uint8_t*)0x20000390 = 0xfe;
*(uint8_t*)0x20000391 = 0x80;
*(uint8_t*)0x20000392 = 0;
*(uint8_t*)0x20000393 = 0;
*(uint8_t*)0x20000394 = 0;
*(uint8_t*)0x20000395 = 0;
*(uint8_t*)0x20000396 = 0;
*(uint8_t*)0x20000397 = 0;
*(uint8_t*)0x20000398 = 0;
*(uint8_t*)0x20000399 = 0;
*(uint8_t*)0x2000039a = 0;
*(uint8_t*)0x2000039b = 0;
*(uint8_t*)0x2000039c = 0;
*(uint8_t*)0x2000039d = 0;
*(uint8_t*)0x2000039e = 0;
*(uint8_t*)0x2000039f = 0xaa;
*(uint16_t*)0x200003a0 = htobe16(0);
*(uint16_t*)0x200003a2 = htobe16(0);
*(uint16_t*)0x200003a4 = htobe16(0);
*(uint16_t*)0x200003a6 = htobe16(0);
*(uint16_t*)0x200003a8 = 0xa;
*(uint8_t*)0x200003aa = 0;
*(uint8_t*)0x200003ab = 0;
*(uint8_t*)0x200003ac = 0;
*(uint32_t*)0x200003b0 = 0;
*(uint32_t*)0x200003b4 = 0;
*(uint64_t*)0x200003b8 = 0;
*(uint64_t*)0x200003c0 = 0;
*(uint64_t*)0x200003c8 = 0;
*(uint64_t*)0x200003d0 = 0;
*(uint64_t*)0x200003d8 = 0;
*(uint64_t*)0x200003e0 = 0;
*(uint64_t*)0x200003e8 = 0;
*(uint64_t*)0x200003f0 = 0;
*(uint64_t*)0x200003f8 = 0;
*(uint64_t*)0x20000400 = 0;
*(uint64_t*)0x20000408 = 0;
*(uint64_t*)0x20000410 = 0;
*(uint32_t*)0x20000418 = 0;
*(uint32_t*)0x2000041c = 0;
*(uint8_t*)0x20000420 = 1;
*(uint8_t*)0x20000421 = 1;
*(uint8_t*)0x20000422 = 0;
*(uint8_t*)0x20000423 = 0;
*(uint8_t*)0x20000428 = 0xac;
*(uint8_t*)0x20000429 = 0x14;
*(uint8_t*)0x2000042a = 0x14;
*(uint8_t*)0x2000042b = 0xbb;
*(uint32_t*)0x20000438 = htobe32(0);
*(uint8_t*)0x2000043c = 0x32;
*(uint16_t*)0x20000440 = 0;
*(uint8_t*)0x20000444 = 0xfe;
*(uint8_t*)0x20000445 = 0x80;
*(uint8_t*)0x20000446 = 0;
*(uint8_t*)0x20000447 = 0;
*(uint8_t*)0x20000448 = 0;
*(uint8_t*)0x20000449 = 0;
*(uint8_t*)0x2000044a = 0;
*(uint8_t*)0x2000044b = 0;
*(uint8_t*)0x2000044c = 0;
*(uint8_t*)0x2000044d = 0;
*(uint8_t*)0x2000044e = 0;
*(uint8_t*)0x2000044f = 0;
*(uint8_t*)0x20000450 = 0;
*(uint8_t*)0x20000451 = 0;
*(uint8_t*)0x20000452 = 0;
*(uint8_t*)0x20000453 = 0;
*(uint32_t*)0x20000454 = 0;
*(uint8_t*)0x20000458 = 0;
*(uint8_t*)0x20000459 = 0;
*(uint8_t*)0x2000045a = 0;
*(uint32_t*)0x2000045c = 0;
*(uint32_t*)0x20000460 = 0;
*(uint32_t*)0x20000464 = 0;
	syscall(__NR_setsockopt, r[1], 0x29, 0x23, 0x20000380, 0xe8);
*(uint16_t*)0x20000080 = 0xa;
*(uint16_t*)0x20000082 = htobe16(0x4e24);
*(uint32_t*)0x20000084 = 0;
*(uint8_t*)0x20000088 = 0xfe;
*(uint8_t*)0x20000089 = 0x80;
*(uint8_t*)0x2000008a = 0;
*(uint8_t*)0x2000008b = 0;
*(uint8_t*)0x2000008c = 0;
*(uint8_t*)0x2000008d = 0;
*(uint8_t*)0x2000008e = 0;
*(uint8_t*)0x2000008f = 0;
*(uint8_t*)0x20000090 = 0;
*(uint8_t*)0x20000091 = 0;
*(uint8_t*)0x20000092 = 0;
*(uint8_t*)0x20000093 = 0;
*(uint8_t*)0x20000094 = 0;
*(uint8_t*)0x20000095 = 0;
*(uint8_t*)0x20000096 = 0;
*(uint8_t*)0x20000097 = 0xaa;
*(uint32_t*)0x20000098 = 0;
	syscall(__NR_sendto, r[0], 0x20000100, 0, 0, 0x20000080, 0x1c);
}

int main()
{
	syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
	char *cwd = get_current_dir_name();
	for (;;) {
		if (chdir(cwd))
			fail("failed to chdir");
		use_temporary_dir();
		loop();
	}
}
